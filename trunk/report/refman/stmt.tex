\section{Statements}\label{Stmts}
At the top leve, BALL is a sequence of statements. Although similar to
statements in C, BALL statements follow different rules. They fall
into three groups:

\begin{verbatim}
statement : function_definition
          | sim_function_definition
          | body_statement
          ;
body_statement : if_statement
               | iteration_statement
               | jump_statement
               | declaration
               | stat_declaration
               | expression_statement
               | activate_statement
               | print_statement
               | assignment_statement
               ;
\end{verbatim}

Body statements are statements that are allowed in the body of if
statements, functions, loops, and such. Function definitions must be
declared in the global scope. However, functions can only be called by
statements placed after they're defined. The same rule applies to
simfunctions.

\subsection{Function Definition}\label{FuncDef}
Function definitions are generated by the following grammar:

\begin{verbatim}
function_definition : 
        "function" identifier "(" parameter_list0 ")" "returns" type
                 ":" "end"
        "function" identifier "(" parameter_list0 ")" "returns" type
                 ":" body_statement_list "end"
                    ;
\end{verbatim}

Any statement starting with the \texttt{function} keyword is
immediately identified as a function definition. The return type of
the function is specified after the parameters, using the keyword
"returns". The function body can be empty. A function accepts a
comma-separated list of parameters specified by the grammar:

\begin{verbatim}
parameter_list0 :
                | parameter_list
                ;
parameter_list : parameter
               | parameter_list "," parameter
               ;
parameter : type identifier
          ;
\end{verbatim}

Parameter lists can be empty, meaning the function does not take any
arguments. An example function definition is as follows:

\begin{verbatim}
function iAddNumbers (number num1, number num2) returns number:
  return num1 + num2;
end
\end{verbatim}

\subsection{Simulation Function Definition}\label{SimDef}
Simulation function definitions require only a brief explanation since
they are in fact simpler to declare than regular functions:

\begin{verbatim}
sim_function_definition : "simfunction" identifier "is:"
        body_statement_list "end"
                        ;
\end{verbatim}

This grammar is very similar to function\_definition but differs in the
following ways: 

\begin{itemize}
\item
  simfunction definitions do not specify any parameters. The
  parameters are implicit: a simulation function only handles two
  \texttt{team} objects named \texttt{team1} and
  \texttt{team2}. \texttt{team1} and \texttt{team2} represent the two
  teams that the sim function is currently simulating for.
\item
  simfunction does not have an explicit return value. Again, this is
  because the return value is restricted to \texttt{team}.
\end{itemize}

\subsection{If Statements}

\begin{verbatim}
if_statement : 
        "if" "(" expression ")" "then:" body_statement_list "end"
        | "if" "(" expression ")" "then:" body_statement_list
                  else_statement "end"
        ;
\end{verbatim}

These are similar to Java if statements, but the delimiters are
\texttt{then:} and \texttt{end} instead of { and }.  expression should
be any boolean expression or other expression that resolves into a
boolean.

\subsection{Iteration Statements}

\begin{verbatim}
iteration_statement : "do:" body_statement_list "end"
                    | "do" expression "times:" body_statement_list
                            "end"
                    | "foreach" identifier "in" identifier ":"
                            body_statement_list "end"
                    ;
\end{verbatim}

The first and second lines produce do loops. A do loop simply loops a
specified amount of times. They 
come in two forms which can be illustrated by the following examples: 

\begin{verbatim}
number i = 1;
do:
  i *= 2;
  if (i >= 1024) then:
       stopdo;
   end
end
\end{verbatim}

This do loop is declared with \texttt{do:} and ends with
\texttt{end}. Everything in between will be repeated indefinitely or
until \texttt{stopdo;} is stated.

\begin{verbatim}
number i = 0;
do 5 times:
   i++
   print "looped" + i + "times!";
end
\end{verbatim}

This second do loop is performed exactly 5 times since that is the
number of loops specified. Note that the number of loops can be any
expression, and code such as \texttt{do num1+num2 times:} is
acceptable.  Finally, the third line of the grammar above produces
\texttt{foreach} statements. A \texttt{foreach} statement iterates
through a list and performs an action on each of the items in
sequence. A \texttt{foreach} statements may as well be halted with a
\texttt{stopdo;} statement. \texttt{foreach} loops are of the form:

\begin{verbatim}
print "The Mets roster is:";
foreach player in Mets's BATTERS:
   print player's name;
end
\end{verbatim}
 
 \subsection{Jump Statements}
The C Reference Manual describes jump statements with: `Jump
statements transfer control unconditionally.'' In BALL, we want to
prevent programmer mistakes by omitting some of such tools which many
programmers flag as ``bad practice.'' Hence, BALL only supports two
jump statements:

\begin{verbatim}
jump_statement : "stopdo" ";"
               | "return" expression ";"
               | "return" ";"
               ;
\end{verbatim}

A \texttt{stopdo;} statement may appear only in an iteration and
terminates the execution of the smallest enclosing such statement:
control passes to the statement following the newly terminated one.

\texttt{return} may only be used in functions. When invoked, the
function halts and returns to its caller. The function may return
nothing, as is the case with functions of return type \texttt{nothing}
(this also happens when letting the function flow off the end). Or the
function may return an expression with with type matching the
function's expected return type.

\subsection{Activate Statement}\label{activateStmt}
The activate statement is short, simple, and requires little explanation:

\begin{verbatim}
activate_statement : "activate" identifier ";"
                   ;
\end{verbatim}

\texttt{activate} is followed by an identifier, which should be the name of a
simulation function defined in the same BALL program. This statement
simply sets the simulation function as the \texttt{active} function for use
in the builtin function \texttt{sim}. For example:

\begin{verbatim}
activate mySimFunction;
sim(Astros, Mets, 3);
\end{verbatim}

This will return the winner of three games between the Astros and the
Mets using \texttt{mySimFunction} as simulation
function. \texttt{activate} may be called multiple times in the same
BALL program.

\subsection{Print Statement}

The print statement is very simple as well: 

\begin{verbatim}
print_statement : "print" expression ";"
                ;
\end{verbatim}

In a nutshell, \texttt{print} will print expression if expression
resolves to a string or the toString value of any team or player that
\texttt{expression} returns. It will also print any
numbers. Additionally, print accept concatenations of any players,
teams, strings or numbers. Example:

\begin{verbatim}
print player1's name + " is " + 5 + "th in the rankings!";
\end{verbatim}

\subsection{Assignment Statement}
The assignment statement is an opportunity to redefine the value of a
variable. The grammar for these assignments is:

\begin{verbatim}
assignment_statement : identifier assignment_operator expression ";"
                     ;
assignment_operator : "=" | "+=" | "-=" | "*=" | "/=" | "%=" ;
\end{verbatim}

A typical variable assignment will be of the form:

\begin{verbatim}
number x = 10;
x = 11; // final value is 11
\end{verbatim}

Assignments can be made with more than just the "=" operator. The
operators "+=", "-=", "*=", "/=", "\%=" are shortcuts for:

\begin{verbatim}
i += num1; // i = i + num1;
i -= num1; // i = i - num1;
i *= num1; // i = i * num1;
i /= num1; // i = i / num1;
i %= num1; // i = i % num1;
\end{verbatim}
 
