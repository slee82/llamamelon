
%%%%%%%%%%
% Lang Ref Man
%%%%%%%%%%
\chapter{Language Reference Manual}\label{manual}

\section{Preamble}
Herein is the language reference manual for the BALL programming language. As a language, BALL is designed for user simplicity and ease of programming. Thus, users can create simulations and manipulate statistics with ease by using the constructs presented below.  

\subsection{Objectives}
The main objective of BALL is to allow users to manipulate simulations of baseball games by creating their own simulation functions to interact with teams. BALL's language constructs are primarily centered around this goal, as well as minor `helper' objectives, such as allowing statistical data to be viewed and compared. Another objective of BALL is to make simulation programming simple and straightforward, allowing the user to accomplish the necessary tasks without having to worry about obscure imports and packages.

\subsection{Abstract Features}
\subsubsection{Types}\label{types}
BALL is a typed language, specifically with five types, \texttt{number},
\texttt{string}, \texttt{list}, \texttt{team}, and \texttt{player}. The
\texttt{number} and \texttt{string} types are simple constants. This is further
explained in the section \ref{keywords} below. The type \texttt{list} is a
collection of objects, which are instances of types. \texttt{list} is therefore
typed itself (see \ref{of}). Thus it is possible to have a \texttt{list} of
\texttt{team} objects, \texttt{player} objects, \texttt{string}s,
\texttt{number}s, or other \texttt{list} objects. \texttt{list} objects are
homogenous, meaning they cannot contain objects of multiple types. The
\texttt{player} type is an object that has attributes of \texttt{string} and
\texttt{number} types. These attributes include the name of the player, whether
the player is a pitcher or not, and the statistics of that player. The
\texttt{team} type is an object that has attributes of \texttt{string},
\texttt{number}, and \texttt{list} types. These attributes include the name of
the team, the team's wins and losses, and the list of every player on the team.

\subsubsection{Language Features}
BALL is a compiled language. Source code is stored in files ending with the \texttt{.ball} extension (for example: \texttt{hello.ball}), and is provided to the BALL compiler, which translates the program into intermediate code (using Java). The compiler then compiles this intermediate Java code into bytecode, which is then executed inside the Java Virtual Machine. Thus the BALL compilation environment must exist within a Java-ready environment. BALL, like many other common programming languages, such as Java upon which BALL is built, is an imperative programming language. It is similar in structure to Java, though numerous changes and innovations, explained later, have been made to facilitate simpler programming.

\section{Lexical Conventions} \label{lexical convention}
BALL has the following five kinds of tokens: identifiers, keywords, constants, operators, and other separators. For example, the following line of code: \texttt{player aroid = "Alex Rodriguez" from Yankees;} breaks down to the following tokens:


\begin{table}[htdp]
\begin{center}
\begin{tabular}{|l|l|}
\hline
Code & Token\\
\hline
\texttt{player} & keyword \\

\texttt{aroid} & identifier\\

\texttt{=} & operator\\

\texttt{"Alex Rodriguez"} & constant\\

\texttt{from} & keyword\\

\texttt{Yankees} & identifier\\

\texttt{;} & separator\\
\hline
\end{tabular}
\caption{Token Example}
\end{center}
\label{token example}
\end{table}
BALL is a strictly case sensitive language, also much like Java.

\subsection{Comments}
BALL comments follow the same format as Java. Single line comments begin with \texttt{//} and are terminated at the end of the line. Multiline comments begin \texttt{/*} and end with \texttt{*/}.
\subsection{Identifiers}
Identifiers are similar to in Java, with the exception that BALL identifiers may begin with a digit, provided that there is at least one alphabet character or underscore in the identifier. This represents a major improvement over Java and allows variable names such as \texttt{2B} representing doubles. That is, identifiers are members of the language defined by the following regular expression: 
\begin{verbatim}
        [a-zA-Z0-9_]*[a-zA-Z_][a-zA-Z0-9_]*
\end{verbatim}

\subsection{Keywords} \label{keywords}
The following are the keywords in the BALL language: \texttt{from}, \texttt{any}, \texttt{stat}, \texttt{where}, \texttt{item}, \texttt{foreach}, \texttt{in}, \texttt{do}, \texttt{stopdo}, \texttt{times}, \texttt{player}, \texttt{team}, \texttt{list}, \texttt{of},  \texttt{number}, \texttt{string}, \texttt{print}, \texttt{if}, \texttt{then}, \texttt{else}, \texttt{return}, \texttt{simfunction}, \texttt{activate}, \texttt{function}, \texttt{returns}, \texttt{nothing}, \texttt{is}, \texttt{end}.
\subsubsection{\texttt{from}}
The \texttt{from} keyword selects an element within a \texttt{list} object. 
\begin{verbatim}
        player aroid = "Alex Rodriguez" from Yankees's BATTERS;
\end{verbatim}

\subsubsection{\texttt{any}}
The \texttt{any} keyword selects a random element within a \texttt{list} object.
\begin{verbatim}
        player dback = any Diamondbacks's PLAYERS;
\end{verbatim}

\subsubsection{\texttt{stat}}
The \texttt{stat} keyword defines a new statistic function. 
\begin{verbatim}
        stat AVG = H / AB;
\end{verbatim}

\subsubsection{\texttt{where}}
The \texttt{where} keyword selects a sublist within a \texttt{list} object. 
\begin{verbatim}
        list of player 300hitters = Dodgers's PLAYERS where (item's AVG > .300);
\end{verbatim}

\subsubsection{\texttt{item}}
The \texttt{item} keyword refers to each element of a \texttt{list} filtered by the \texttt{where} keyword. 
\begin{verbatim}
        list 300hitters = Dodgers's PLAYERS where (item's AVG > .300);
\end{verbatim}

\subsubsection{\texttt{foreach}} \label{foreach}
The \texttt{foreach} keyword iterates through each element in a \texttt{list} object. 
\begin{verbatim}
        foreach p in Royals's PITCHERS: 
               print p's name;
        end
\end{verbatim}

\subsubsection{\texttt{in}}
The \texttt{in} keyword is integral to the \texttt{foreach} loop structure. See \ref{foreach} above.

\subsubsection{\texttt{do}} \label{do}
The \texttt{do} keyword creates an iterating loop, similar to \texttt{do}/\texttt{while} or \texttt{for} in Java.
\begin{verbatim}
        number n=0;
        do 5 times:
            n++;
            print "hello "+n;
        end
\end{verbatim}

\subsubsection{\texttt{stopdo}} \label{stopdo}
The \texttt{stopdo} keyword is similar to the \texttt{break} keyword in Java. It escapes a \texttt{do} loop before the completion of all iterations.
\begin{verbatim}
    do 5 times:
        player dback = any Diamondbacks's PLAYERS;
        print dback's name;
        if (dback's name is "Jon Garland") then:
            stopdo;
        end
    end
\end{verbatim}

\subsubsection{\texttt{times}}
The \texttt{times} keyword is integral to the \texttt{do} loop. See \ref{do} above.

\subsubsection{\texttt{player}}
The \texttt{player} keyword defines a new \texttt{player} object.
\begin{verbatim}
    player nat = any Nationals's PLAYERS;
\end{verbatim}

\subsubsection{\texttt{team}}
The \texttt{team} keyword defines a new \texttt{team} object.
\begin{verbatim}
    team champs = sim(Astros, Reds, 1);
\end{verbatim}

\subsubsection{\texttt{list}} \label{list}
The \texttt{list} keyword defines a new \texttt{list} object.
\begin{verbatim}
    list of player 300hitters = RedSox's PLAYERS where (item's AVG > .300);
\end{verbatim}

\subsubsection{\texttt{of}}\label{of}
The \texttt{of} keyword is integral to the \texttt{list} declaration. See \ref{list}


\subsubsection{\texttt{number}}
The \texttt{number} keyword defines a new \texttt{number} instance.
\begin{verbatim}
    player bigZ = "Carlos Zambrano" from Cubs's PITCHERS;
    number n = bigZ's ERA;
\end{verbatim}

\subsubsection{\texttt{string}}
The \texttt{string} keyword defines a new \texttt{string} instance. 
\begin{verbatim}
    string name = "Lance Berkman";
\end{verbatim}

\subsubsection{\texttt{print}}
The \texttt{print} keyword prints something to the standard output.
\begin{verbatim}
    player vlad = "Vladimir Guerrero" from Angels's BATTERS;
    print vlad's AVG;
\end{verbatim}

\subsubsection{\texttt{if}} \label{if}
The \texttt{if} keyword opens an \texttt{if} statement.
\begin{verbatim}
    player bro = any Twins's PLAYERS;
    print bro's name;
    if (bro's name is "Joe Mauer") then:
            print "What an average!";
    end
\end{verbatim}

\subsubsection{\texttt{then}}
The \texttt{then} keyword is integral to the \texttt{if} statement. See \ref{if} above.

\subsubsection{\texttt{else}}
The else keyword begins and alternate statement to a previous if statement.
\begin{verbatim}
    player roar = any Tigers's PITCHER;
    print roar's name;
    if (roar's name is "Justin Verlander") then:
        print "Wow, heck of an ERA!";
    else:
        print "You're not Verlander!";
    end
\end{verbatim}

\subsubsection{\texttt{return}}
The \texttt{return} keyword is used to return either the winning team in a simfunction (see \ref{simfunction} below) or a value required for a returning function (see \ref{function}).
\begin{verbatim}
    function simple(player p) returns string:
        return p's name;
    end
\end{verbatim}

\subsubsection{\texttt{simfunction}} \label{simfunction}
The \texttt{simfunction} keyword is used to create a new simulation function used to carry out the actual simulations of games. [Note that \texttt{team1} and \texttt{team2} are implicitly passed to the \texttt{simfunction} whenever \texttt{sim} is called. These are implicit keywords.]
\begin{verbatim}
    simfunction badSim is:
        if (team1's W > team2's W ) then:
            return team1;
        else:
            return team2;
        end
    end

\end{verbatim}

\subsubsection{\texttt{activate}}\label{activate}
The \texttt{activate keyword} is used to apply a \texttt{simfunction} for use by the function \texttt{sim}.
\begin{verbatim}
    activate badSim;
\end{verbatim} 

\subsubsection{\texttt{function}} \label{function}
The \texttt{function} keyword is used to define a new function.
\begin{verbatim}
    function simple(player p) returns string:
        return p's name;
    end
\end{verbatim}

\subsubsection{\texttt{returns}}\label{returns}
The \texttt{returns} keyword is used to define the return type of a function. See \ref{function} above.

\subsubsection{\texttt{nothing}}\label{nothing}
The \texttt{nothing} keyword replaces Java's \texttt{void} keyword. It is a return type for functions that don't return anything.
\begin{verbatim}
    function simple(player p) returns nothing:
        print p's avg;
    end
\end{verbatim}

\subsubsection{\texttt{is}}\label{is}
The \texttt{is} keyword is integral to the \texttt{simfunction} declaration (see \ref{simfunction}). 

\subsubsection{\texttt{end}}\label{end}
The \texttt{end} keyword is required at the end of every loop, if-statement, function, and \texttt{simfunction} declaration. See \ref{foreach}, \ref{do}, \ref{if}, \ref{simfunction}, \ref{function} above.

\subsection{Constants}
Much like Java, BALL constants consist of two major categories, numeric constants and string constants. These are both touched upon briefly in section \ref{types} "Types."
\subsubsection{Numeric Constants}
Numeric constants, because they apply to the \texttt{number} type, are treated as only one type. Specifically, they can contain integer or float values. [Integer values, such as a number of hits; float values such as a batting average.] The unary minus operation is also supported, so a numeric constant can be negative or positive. Numeric constants are members of the language defined by the following regular expression. 
\begin{verbatim}
    0 | [-]?[0-9]*[.]?[0-9]+
\end{verbatim}

\subsubsection{String Constants}
String constants are character sequences. They must begin and end with quotation marks. Note that BALL does not have a char type. All character sequences must be within double-quotation marks and are treated as string constants. All special escaped characters that Java supports are supported by BALL, including but not limited to the ones in Table \ref{escape}.
\begin{table}[htdp]
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\texttt{\textbackslash n} & \texttt{\textbackslash t} & \texttt{\textbackslash \textbackslash} & \texttt{\textbackslash "}\\
\hline
\end{tabular}
\caption{Some Acceptable Escape Characters}\label{escape}
\end{center}
\end{table}%

\subsection{Operators}
BALL contains six types of operators: assignment, logical, comparison, arithmetic, incrementor, and accessor. Generally, these operators are similar to in other standard programming languages such as Java, but some notable exceptions, shown below, are implemented in BALL.

\subsubsection{Assignment Operators}
Table \ref{assigntable} shows the assignment operators.
\begin{table}[htdp]
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
\texttt{=} & \texttt{+=} & \texttt{-=} & \texttt{*=} & \texttt{/=} & \texttt{\%=}\\
\hline
\end{tabular}
\caption{BALL's Assignment Operators}\label{assigntable}
\end{center}
\end{table}%
They act just like in Java.

\subsubsection{Logical Operators}
Table \ref{logical operators} shows the logical operators and their Java equivalents.
\begin{table}[htdp]
\begin{center}
\begin{tabular}{|c|c|}
\hline
BALL & Java\\
\hline
\texttt{and} & \texttt{\&\&} \\
\texttt{or} & \texttt{\textbar \textbar} \\
\hline
\end{tabular}
\caption{BALL's Logical Operators}\label{logical operators}
\end{center}
\end{table}%

\subsubsection{Comparison Operators}
Table \ref{comparison operators} shows the logical operators and their Java equivalents. 
\begin{table}[htdp]
\begin{center}
\begin{tabular}{|c|c|}
\hline
BALL & Java\\
\hline
\texttt{is} & \texttt{==} \\
\texttt{isnot} & \texttt{!=} \\
\texttt{\textgreater} & \texttt{\textgreater} \\
\texttt{\textless} & \texttt{\textless} \\
\texttt{\textgreater =} & \texttt{\textgreater =}\\
\texttt{\textless =} & \texttt{\textless =}\\
\hline
\end{tabular}
\caption{BALL's Comparison Operators}\label{comparison operators}
\end{center}
\end{table}%

\subsubsection{Arithmetic Operators}
The following are the arithmetic operators: 
Table \ref{arithmetictable} shows the arithmetic operators. They act just like in Java. The unary minus also fits in this category.
\begin{table}[htdp]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\texttt{+} & \texttt{-} & \texttt{*} & \texttt{/} & \texttt{\%}\\
\hline
\end{tabular}
\caption{BALL's Arithmetic Operators}\label{arithmetictable}
\end{center}
\end{table}%

\subsubsection{Incrementor Operators}
Table \ref{incremtable} shows the incrementor operators. These can be prefix or postfix. In either case, the behavior is equivalent to Java.
\begin{table}[htdp]
\begin{center}
\begin{tabular}{|c|c|}
\hline
\texttt{++} & \texttt{----}\\
\hline
\end{tabular}
\caption{BALL's Incrementor Operators}\label{incremtable}
\end{center}
\end{table}%

\subsubsection{Accessor}
Table \ref{accessortable} shows the one accessor operator. It acts like a period in Java, returning the value of an attribute of an object. Thus, \texttt{p's name} in BALL is the same as \texttt{p.name} in Java.
\begin{table}[htdp]
\begin{center}
\begin{tabular}{|c|}
\hline
\texttt{'s}\\
\hline
\end{tabular}
\caption{BALL's Incrementor Operators}\label{accessortable}
\end{center}
\end{table}%

\subsection{Separators}
The following are the separators in BALL: whitespace, comma, semicolon, colon, the keyword \texttt{end}, parentheses, and square brackets. Some of these are delimiters. Whitespace is always ignored, except in strings. Square brackets are used for defining lists.

\section{Expressions}
A BALL expression is evaluated in a predefined hierarchy and returns a single value. An expression can return a value of any type. The precedence of the operators when evaluating an expression is the same as the order they are explained in this section, with highest precedence first. The associativity of the operators will be explained in each section. The order in which operands are evaluated is undefined, even when the expressions have side effects.

\subsection{Atomic Expressions}
\begin{verbatim}
atom_expression : identifier
                | number
                | string
                | list_initializer
                | "nothing"
                | "(" expression ")" // completes the cycle
                ;
\end{verbatim} 

An atomic expression is an identifier, number constant, string
constant, list initializer, and an expression in
parentheses. Identifiers will return the value of the variable bound
to the identifier, if it is a properly declared variable of type
\texttt{number}, \texttt{list}, \texttt{string}, \texttt{team}, or
\texttt{player}.

\subsection{Primary Expressions}
\begin{verbatim}
primary_expression : atom_expression
                   | function_call
                   ;
\end{verbatim} 
A primary expression is either an atomic expression or a function
call. Function calls in BALL are similar to function calls in C, with
a few exceptions.  Arguments are specified inside a list separated by
commas and delimited by parentheses.  Functions can only be referenced
by identifiers. BALL does not support storing functions inside
constructs such as lists, and thus functions can only be referenced
through their name that exists in the global scope. In addition,
function names cannot be overloaded.

\subsection{Postfix Expressions}
Postfix expressions are left-associative.
\begin{verbatim}
postfix_expression : primary_expression
                   | postfix_expression "'s" identifier
                   | postfix_expression "where" "(" expression ")"
                   | postfix_expression "++"
                   | postfix_expression "--"
                   ;
\end{verbatim}

\subsubsection{Attribute Calling}
The \texttt{'s} accessor operator acts much like the period
(\texttt{.}) character in Java. The left operand of the \texttt{'s}
evaluates to either a \texttt{team} or \texttt{player} object. The
right operand is an identifier that represents the name of a stat or
attribute associated with the value of the left operand. For example:
\begin{verbatim}
    number teamwins = Orioles's W;
\end{verbatim}
Assuming \texttt{Orioles} is a loaded team, and since \texttt{W} is a
built-in stat, this program successfully compiles and stores the value
of the Orioles' wins into \texttt{teamwins}.

\subsubsection{\texttt{where} Expression}
\texttt{where} is used to filter lists. The left side evaluates to a
list. The right side is a boolean expression. Each element of the left
side is tested with the boolean expression. If and only if the boolean
expression returns true on the element, the element will be inside the
filtered and returned list. To reference the element being checked
inside the boolean expression, use the \texttt{item} keyword. For
example:

\begin{verbatim}
    list of player 200hitters = Reds's PLAYERS 
        where (item's AVG > .200);
\end{verbatim}

The initial list on which the filtering will take place is the list \texttt{Reds's PLAYERS}, assuming that \texttt{Reds} is a team that has been loaded. The final, filtered list, will be stored in the list \texttt{200hitters}, and will contain only the players from the first list who fit the requirement of having an AVG over .200.

\subsubsection{Postfix Operators}
The postfix operators \texttt{++} and \texttt{----} behave identically with C and Java's increment/decrement operators, as long as the left-hand side is a name of a \texttt{number} variable. The variable's value will be returned before it is incremented/decremented. \texttt{++} increments the variable and \texttt{----} decrements the variable.

\subsection{Unary Expressions}
\begin{verbatim}
unary_expression : postfix_expression
                 | "++" unary_expression
                 | "--" unary_expression
                 | primary_expression "from" unary_expression
                 | "any" unary_expression
                 ;
\end{verbatim}
Unary expressions are evaluated right to left (right-associative).

\subsubsection{Prefix Operators}
The prefix operators \texttt{++} and \texttt{----} behave identically with C and Java's increment/decrement operators, as long as the left-hand side is a name of a \texttt{number} variable. The variable's value will be returned after it is incremented/decremented. \texttt{++} increments the variable and \texttt{----} decrements the variable.

\subsubsection{\texttt{from} Expression}
\texttt{from} is a matcher operation. The right operand is a
\texttt{list}, and the left operand is any object. The first element
of the right operand that "matches" the left operand will be
returned. If the elements are \texttt{player} objects, matching is
defined as an equivalent \texttt{name} or equivalent \texttt{player}
object. For everything else, matching is defined as being the same
object, equivalent to the \texttt{is} keyword. [See \ref{is}.]

However, what should \texttt{from} return when it cannot match the
left hand side with any element in the right hand side? The return
value, when used as the argument for the builtin function
\texttt{isValid}, must return a \texttt{false} value. The exact value
itself is implementation dependent.

\subsubsection{\texttt{any} Expression}
The right operand of \texttt{any} is a \texttt{list}. The expression returns one random element from the \texttt{list}.

\subsection{Multiplicative Operations}\label{multiplication}
\begin{verbatim}
multiplication_expression : 
        unary_expression
        | multiplication_expression "*" unary_expression
        | multiplication_expression "/" unary_expression
        | multiplication_expression "%" unary_expression
        ;
\end{verbatim}

All multiplicative operators are left-associative. The order in which the operands are evaluated (left first or right first) implementation dependent. The operand expressions must have type \texttt{number}. The result of the operator \texttt{*} is the product of the two operands. If an implementation implicitly stores numbers as both integers and floating point numbers, both operands must be converted to floating point if one of the operands has a floating-point internal type.
The result of the operator \texttt{/} is the division between the two operands. Result of division by zero is implementation-defined. Rules on conversion of the two operand types are identical with the \texttt{*} operator.
The operator \texttt{\%} returns the modulo of the two numbers. Rules of the division operator apply here as well.

\subsection{Addition Operations}\label{addition}
\begin{verbatim}
addition_expression : 
        multiplication_expression
        | addition_expression "+" multiplication_expression
        | addition_expression "-" multiplication_expression
        ;
\end{verbatim}

Both addition and subtraction operators are left-associative. The order in which the operands are evaluated is implementation dependent. The operand expressions for \texttt{-} must evaluate to type \texttt{number}. The operand expressions for \texttt{+} must evaluate to and behaves as shown in table \ref{plusstuff}.
\begin{table}[htdp]
\begin{center}
\begin{tabular}{|c|c|p{7cm}|}
\hline
Left Type & Right Type & Result\\
\hline
\texttt{number} & \texttt{number} & The two \texttt{number}s are added together.\\
\texttt{list of T} & \texttt{list of T} & The right \texttt{list} is appended to the left, into a new \texttt{list}.\\
\texttt{string} & any object & The string representation of the right is concatenated to the left.\\
any object & \texttt{string} & The right is concatenated to the string representation of the left.\\
\hline
\end{tabular}
\end{center}
\caption{Operand Evaluation and Behavior for \texttt{+}.}\label{plusstuff}
\end{table}%



Rules for internal conversion for numeric operand values are identical to the multiplication operator in section \ref{multiplication}. 
\texttt{-} returns the subtraction between the two operands. Rules for internal conversion for the operand values are identical to the addition operator.

\subsection{Comparison Expressions}
\begin{verbatim}
comparison_expression : 
        addition_expression
        | comparison_expression "is" addition_expression        | comparison_expression "isnot" addition_expression        | comparison_expression ">" addition_expression        | comparison_expression "<" addition_expression        | comparison_expression ">=" addition_expression        | comparison_expression "<=" addition_expression
\end{verbatim}

Evaluation between a series of comparison operations is done from left to right (all comparison operators are left-associative).  Comparison operators can only compare two values of the same type.
The equality operator \texttt{is} has behavior detailed in table in table \ref{isbehavior}. The inequality operator \texttt{isnot} returns true when \texttt{is} returns false and vice versa. The rest of the comparison operators only work on numbers.

\begin{table}[htdp]
\begin{center}
\begin{tabular}{|c|p{8cm}|}
\hline
Type & Returns true only if\\
\hline
\texttt{number} & The two numbers are equal\\
\texttt{string} & The strings are equal (case sensitive)\\
anything else & Both refer to the same object in memory\\
\hline
\end{tabular}
\end{center}
\caption{Behavior of \texttt{is}.}\label{isbehavior}
\end{table}

\subsection{Logical Expressions}
\begin{verbatim}
logical_not_expression : 
        comparison_expression
        | "not" logical_not_expression
        ;
logical_and_expression : 
        logical_not_expression
        | logical_and_expression "and" logical_not_expression
        ;
logical_or_expression : 
        logical_and_expression
        | logical_or_expression "or" logical_and_expression
        ;
\end{verbatim}

Logical expressions are ordered, with decreasing precedence, as NOT, AND, and OR expressions. Each of these expressions take operands of type \texttt{number} and returns the truth value of the expression.


\texttt{not} takes a single expression and returns \texttt{false} if the original expression is \texttt{true} and \texttt{true} if the original expression is \texttt{false}.
\texttt{and} takes two expressions and returns \texttt{true} if both expressions return \texttt{true}, \texttt{false} otherwise. \texttt{or} takes two expressions and returns \texttt{false} if both expressions return \texttt{false}, \texttt{true} otherwise.


The logical \texttt{or} expression is the expression with the lowest precedence, and is made of terms of expressions with higher precedence. An \texttt{expression} proper is a logical \texttt{or} expression.

\begin{verbatim}
expression : logical_or_expression
           ;
\end{verbatim}


\section{Declarations}\label{Declarations}
Declarations specify how BALL will set aside a new variable within the
scope of the declaration. Declarations have the form:

\begin{verbatim}
declaration : type variable_declarators ";"
            ;
variable_declarators : variable_declarator
                     | variable_declarators "," variable_declarator
                     ;
variable_declarator : identifier
                    | identifier "=" expression
                    ;
\end{verbatim}

\texttt{variable\_declarators} is a comma-separated parentheses
delimited list of declarators. Each declarator contains a name and
optionally an expression that initializes the variable's value. The
expression's type must match the type of the declaration statement.

\subsection{Type Specifiers}

The type specifiers in BALL are: 

\begin{verbatim}
type : "number" | "string"
     | "list"   | "team"
     | "player" | "nothing"
     | list_type
     ;

list_type : "list" "of" type
          ;
\end{verbatim}

List types are declared with the type of their contents.  The type
\texttt{nothing} is only used when specifying return values for
functions. For example:

\begin{verbatim}
function printHello (string helloString) returns nothing:
   print helloString;
end
\end{verbatim}

\subsection{Meaning of Declarations}

Declarations map an identifier to an expression. Since an expression
can produce any \texttt{atom\_expression} , this allows for
declarations such as \texttt{number someNumber=9;} and \texttt{string
  someString="Hello!";}. But expressions may produce other
combinations, and their return value will be mapped to the
identifier. In this example, \texttt{aTeam} will be mapped to the
return value of the load function: \texttt{team aTeam =
  load(myTeam.team);} Furthermore, identifiers could be mapped to the
return values of arithmetic expressions or list manipulations.

\subsection{Declaring a List}\label{ListDecl}

\begin{verbatim}
list_initializer : "[" variable_list "]"
                 | type "[" "]"
                 ;
variable_list : expression
              | variable_list "," expression
              ;
\end{verbatim}

Lists are declared as a list of expressions (separated by commas)
between square brackets. Each expression must evaluate to the same
type as the list's expected content type.

BALL lists determine their type by looking at the arguments. If the
new list is an empty list, no arguments means lists cannot know what
type it contains. Therefore, the type of object the list is going to
hold needs to be specified for empty lists.

\subsection{Declaring Players and Teams}

Players and teams cannot be created inside a program. They must be
loaded from a team file formatted in CSV.

\subsection{Declaring a Stat}

Stats are small, portable functions that encapsulate just a single
expression that acts on a \texttt{player} or \texttt{team}
object. Whether the stat acts on a player or a team depends what stat
it calls to derive its value. Both \texttt{player} and \texttt{team}
objects have predefined stats. User-defined stats act on players if
the stats they call all act on players. The same goes for team
stats. However, if both player and team stats are called by a
user-defined stat, the compiler should fail to generate the
code. Similarly, if there are no stats called by a user-defined stat,
it should also fail because the use of the stat cannot be derived.

\begin{table}[htdp]
\begin{center}
\begin{tabular}{|c|c|p{5cm}|}
\hline
Name & Type & Meaning\\
\hline
\texttt{IP} & Pitcher & Innings Pitched\\
\texttt{K} & Pitcher & Strikeouts\\
\texttt{H} & Pitcher & Hits Allowed\\
\texttt{BB} & Pitcher & Walks Allowed\\
\texttt{ER} & Pitcher & Earned Runs\\
\texttt{AB} & Batter & At Bats\\
\texttt{R} & Batter & Runs\\
\texttt{H} & Batter & Hits\\
\texttt{2B} & Batter & Doubles\\
\texttt{3B} & Batter & Triples\\
\texttt{HR} & Batter & Home Runs\\
\texttt{BB} & Batter & Walks\\
\hline
\end{tabular}
\end{center}
\caption{Primitive Stats for \texttt{player} objects}\label{playerstats}
\end{table}%

\begin{table}[htdp]
\begin{center}
\begin{tabular}{|c|p{5cm}|}
\hline
Name & Meaning\\
\hline
\texttt{W} & Games Won\\
\texttt{L} & Games Lost\\
\hline
\end{tabular}
\end{center}
\caption{Primitive Stats for \texttt{team} objects}\label{teamstats}
\end{table}%


\begin{table}[htdp]
\begin{center}
\begin{tabular}{|c|c|c|p{5cm}|}
\hline
Object Type & Name & Return Type & Meaning\\
\hline
\texttt{player} & \texttt{name} & \texttt{string} & Name loaded from CSV \\
\texttt{team} & \texttt{teamname} & \texttt{string} & Team name from
CSV \\
\texttt{team} & \texttt{BATTERS} & \texttt{list of player} & Players
marked as batters \\
\texttt{team} & \texttt{PITCHERS} & \texttt{list of player} & Players
marked as pitchers \\
\texttt{team} & \texttt{PLAYERS} & \texttt{list of player} & All
players \\
\hline
\end{tabular}
\end{center}
\caption{Builtin Attributes}\label{teamstats}
\end{table}%

When defining a new stat, the user will need to build upon primitive
stats so BALL can derive what object the stat is for. For example:

\begin{verbatim}
stat ERA = ER/IP*9;
\end{verbatim}

This line of code defines a new stat for pitchers: the Earned Run
Average. A user may now access this 
stat from any pitcher just like he would access a primitive stat:
\texttt{player1's ERA}.

Stats return numbers. The user should be able to collect a stat as
a number at any time with code such as: 

\begin{verbatim}
number player1ERA = player1's ERA;
\end{verbatim}

\section{Statements}\label{Stmts}
At the top leve, BALL is a sequence of statements. Although similar to
statements in C, BALL statements follow different rules. They fall
into three groups:

\begin{verbatim}
statement : function_definition
          | sim_function_definition
          | body_statement
          ;
body_statement : if_statement
               | iteration_statement
               | jump_statement
               | declaration
               | stat_declaration
               | expression_statement
               | activate_statement
               | print_statement
               | assignment_statement
               ;
\end{verbatim}

Body statements are statements that are allowed in the body of if
statements, functions, loops, and such. Function definitions must be
declared in the global scope. However, functions can only be called by
statements placed after they're defined. The same rule applies to
simfunctions.

\subsection{Function Definition}\label{FuncDef}
Function definitions are generated by the following grammar:

\begin{verbatim}
function_definition : 
        "function" identifier "(" parameter_list0 ")" "returns" type
                 ":" "end"
        "function" identifier "(" parameter_list0 ")" "returns" type
                 ":" body_statement_list "end"
                    ;
\end{verbatim}

Any statement starting with the \texttt{function} keyword is
immediately identified as a function definition. The return type of
the function is specified after the parameters, using the keyword
"returns". The function body can be empty. A function accepts a
comma-separated list of parameters specified by the grammar:

\begin{verbatim}
parameter_list0 :
                | parameter_list
                ;
parameter_list : parameter
               | parameter_list "," parameter
               ;
parameter : type identifier
          ;
\end{verbatim}

Parameter lists can be empty, meaning the function does not take any
arguments. An example function definition is as follows:

\begin{verbatim}
function iAddNumbers (number num1, number num2) returns number:
  return num1 + num2;
end
\end{verbatim}

\subsection{Simulation Function Definition}\label{SimDef}
Simulation function definitions require only a brief explanation since
they are in fact simpler to declare than regular functions:

\begin{verbatim}
sim_function_definition : "simfunction" identifier "is:"
        body_statement_list "end"
                        ;
\end{verbatim}

This grammar is very similar to function\_definition but differs in the
following ways: 

\begin{itemize}
\item
  simfunction definitions do not specify any parameters. The
  parameters are implicit: a simulation function only handles two
  \texttt{team} objects named \texttt{team1} and
  \texttt{team2}. \texttt{team1} and \texttt{team2} represent the two
  teams that the sim function is currently simulating for.
\item
  simfunction does not have an explicit return value. Again, this is
  because the return value is restricted to \texttt{team}.
\end{itemize}

\subsection{If Statements}

\begin{verbatim}
if_statement : 
        "if" "(" expression ")" "then:" body_statement_list "end"
        | "if" "(" expression ")" "then:" body_statement_list
                  else_statement "end"
        ;
\end{verbatim}

These are similar to Java if statements, but the delimiters are
\texttt{then:} and \texttt{end} instead of { and }.  expression should
be any boolean expression or other expression that resolves into a
boolean.

\subsection{Iteration Statements}

\begin{verbatim}
iteration_statement : "do:" body_statement_list "end"
                    | "do" expression "times:" body_statement_list
                            "end"
                    | "foreach" identifier "in" identifier ":"
                            body_statement_list "end"
                    ;
\end{verbatim}

The first and second lines produce do loops. A do loop simply loops a
specified amount of times. They 
come in two forms which can be illustrated by the following examples: 

\begin{verbatim}
number i = 1;
do:
  i *= 2;
  if (i >= 1024) then:
       stopdo;
   end
end
\end{verbatim}

This do loop is declared with \texttt{do:} and ends with
\texttt{end}. Everything in between will be repeated indefinitely or
until \texttt{stopdo;} is stated.

\begin{verbatim}
number i = 0;
do 5 times:
   i++
   print "looped" + i + "times!";
end
\end{verbatim}

This second do loop is performed exactly 5 times since that is the
number of loops specified. Note that the number of loops can be any
expression, and code such as \texttt{do num1+num2 times:} is
acceptable.  Finally, the third line of the grammar above produces
\texttt{foreach} statements. A \texttt{foreach} statement iterates
through a list and performs an action on each of the items in
sequence. A \texttt{foreach} statements may as well be halted with a
\texttt{stopdo;} statement. \texttt{foreach} loops are of the form:

\begin{verbatim}
print "The Mets roster is:";
foreach player in Mets's BATTERS:
   print player's name;
end
\end{verbatim}
 
 \subsection{Jump Statements}
The C Reference Manual describes jump statements with: `Jump
statements transfer control unconditionally.'' In BALL, we want to
prevent programmer mistakes by omitting some of such tools which many
programmers flag as ``bad practice.'' Hence, BALL only supports two
jump statements:

\begin{verbatim}
jump_statement : "stopdo" ";"
               | "return" expression ";"
               | "return" ";"
               ;
\end{verbatim}

A \texttt{stopdo;} statement may appear only in an iteration and
terminates the execution of the smallest enclosing such statement:
control passes to the statement following the newly terminated one.

\texttt{return} may only be used in functions. When invoked, the
function halts and returns to its caller. The function may return
nothing, as is the case with functions of return type \texttt{nothing}
(this also happens when letting the function flow off the end). Or the
function may return an expression with with type matching the
function's expected return type.

\subsection{Activate Statement}\label{activateStmt}
The activate statement is short, simple, and requires little explanation:

\begin{verbatim}
activate_statement : "activate" identifier ";"
                   ;
\end{verbatim}

\texttt{activate} is followed by an identifier, which should be the name of a
simulation function defined in the same BALL program. This statement
simply sets the simulation function as the \texttt{active} function for use
in the builtin function \texttt{sim}. For example:

\begin{verbatim}
activate mySimFunction;
sim(Astros, Mets, 3);
\end{verbatim}

This will return the winner of three games between the Astros and the
Mets using \texttt{mySimFunction} as simulation
function. \texttt{activate} may be called multiple times in the same
BALL program.

\subsection{Print Statement}

The print statement is very simple as well: 

\begin{verbatim}
print_statement : "print" expression ";"
                ;
\end{verbatim}

In a nutshell, \texttt{print} will print expression if expression
resolves to a string or the toString value of any team or player that
\texttt{expression} returns. It will also print any
numbers. Additionally, print accept concatenations of any players,
teams, strings or numbers. Example:

\begin{verbatim}
print player1's name + " is " + 5 + "th in the rankings!";
\end{verbatim}

\subsection{Assignment Statement}
The assignment statement is an opportunity to redefine the value of a
variable. The grammar for these assignments is:

\begin{verbatim}
assignment_statement : identifier assignment_operator expression ";"
                     ;
assignment_operator : "=" | "+=" | "-=" | "*=" | "/=" | "%=" ;
\end{verbatim}

A typical variable assignment will be of the form:

\begin{verbatim}
number x = 10;
x = 11; // final value is 11
\end{verbatim}

Assignments can be made with more than just the "=" operator. The
operators "+=", "-=", "*=", "/=", "\%=" are shortcuts for:

\begin{verbatim}
i += num1; // i = i + num1;
i -= num1; // i = i - num1;
i *= num1; // i = i * num1;
i /= num1; // i = i / num1;
i %= num1; // i = i % num1;
\end{verbatim}
 
\section{Scope}
All declarations made outside of functions, loops, or if-statements
are global. Functions themselves must also be global. However, the
scope of all declarations made inside of functions, loops, or if
statements ends at the end of the \texttt{body\_statement\_list}. The
end keyword marks the end of the deepest
\texttt{body\_statement\_list}.

\section{Built-in Functions}

\subsection{Load Function}
The \texttt{load} function is used to import external
comma-separated-value team files (see CSV Specification for csv format
and specification) into \texttt{team} objects in a file. The syntax
is:

\begin{verbatim}
load(string);
\end{verbatim}
Example: 
\begin{verbatim}
team Astros = load("Astros.team");
\end{verbatim}

\subsection{Rand Function}
The rand function is used to generate a random (float) number between
two given arguments. The syntax is:

\begin{verbatim}
rand(number, number);
\end{verbatim}
Example: 
\begin{verbatim}
number randomNum = rand(0,1);
\end{verbatim}

\subsection{Max Function}
The max function is used to determine the largest of two given
arguments. The syntax is:

\begin{verbatim}
max(number, number);
\end{verbatim}
Example: 
\begin{verbatim}
number larger = max(5,100); // 100
\end{verbatim}
 
\subsection{Min Function}
The min function is used to determine the smallest of two given arguments. The syntax is:

\begin{verbatim}
min(number, number);
\end{verbatim}
Example: 
\begin{verbatim}
number larger = min(5,100); // 5
\end{verbatim}

\subsection{Top Players Function}
The top function is used to generate a sublist of players representing
the top players in that list with respect to the stat. The syntax is:

\begin{verbatim}
topPlayers(number, list, player stat);
\end{verbatim}
Example: 
\begin{verbatim}
list of player top5b = topPlayers(5, Braves, AVG);
\end{verbatim}

\subsection{Top Teams Function}
The \texttt{topTeams} function is used to generate a sublist of teams
representing the top teams in that list with respect to the stat. The
list is sorted with teams having the biggest tested stat values
first. The syntax is:

\begin{verbatim}
topTeams(number, list, team stat);
\end{verbatim}
Example: 
\begin{verbatim}
list of team top5t = topTeams(5, [Braves, Dodgers, Orioles], W);
\end{verbatim}

\subsection{Bottom Functions}
The \texttt{bottom} functions are counterparts to the \texttt{top}
functions. Instead of descending sort, the resulting list is sorted
least stat value first.

\begin{verbatim}
list of player bot5a = bottomPlayers(5, Braves, AVG);
list of team bot5b = bottomTeams(5, [Braves, Dodgers, Orioles], W);
\end{verbatim}

\subsection{IsValid Function}
The \texttt{isValid} function is used to determine whether a
\texttt{from} expression returns a value successfully. When the
argument is what \texttt{from} returns in failure, \texttt{isValid}
returns \texttt{false}. Otherwise, it returns \texttt{true}.

\begin{verbatim}
isValid(any type);
\end{verbatim}
Example: 
\begin{verbatim}
isValid("a" from string[]); // false;
isValid(3 from number[]); // false;
isValid(-3 from [2, 4, 5, 1]); // false;
isValid(5 from [2, 4, 5, 1]); // true;
isValid(dodgers from [dodgers, astros, reds, yankees]); // true;
\end{verbatim}

\subsection{Sim Function}
The \texttt{sim} function is BALL's main function. When this function
is called, it takes the activated (see section \ref{activateStmt})
simfunction (see section \ref{simDef}) and runs it on the two teams a
number of times. The team that gets returned is the team that has the
larger number of wins. The syntax is:
\begin{verbatim}
sim(team,team,number);
\end{verbatim}
Example: 
\begin{verbatim}
sim(Rockies,Giants,5); 
\end{verbatim}

\section{CSV Specifications}\label{csv} 
The following is an example of a CSV used as a team file. This file
would be called Astros.team and contains information on the whole
team, batters, and pitchers, and their stats.

\begin{verbatim}
Team Name:Houston Astros
Header:W,L
74,88

Type:Batter
Header:Name,AB,R,H,2B,3B,HR,BB
Ivan Rodriguez,327,41,82,15,2,8,13
Lance Berkman,460,73,126,31,1,25,97
Kazuo Matsui,476,56,119,20,2,9,34
Miguel Tejada,635,83,199,46,1,14,19
Geoff Blum,381,34,94,14,1,10,33
Carlos Lee,610,65,183,35,1,26,41
Michael Bourn,606,97,173,27,12,3,63
Hunter Pence,585,76,165,26,5,25,58
Wandy Rodriguez,63,4,8,3,0,0,1
Roy Oswalt,49,4,6,0,0,0,2
Brian Moehler,42,0,1,0,0,0,1
Mike Hampton,37,6,12,1,0,1,2
Russ Ortiz,28,2,5,0,0,1,1
Bud Norris,16,1,3,0,0,0,0


Type:Pitcher
Header:Name,IP,H,ER,HR,BB,K,BF
Wandy Rodriguez,205.2,192,69,21,63,193,849
Roy Oswalt,181.1,183,83,19,42,138,757
Brian Moehler,154.2,187,94,21,51,91,694
Mike Hampton,112.0,128,66,13,46,74,494
Russ Ortiz,85.2,95,53,8,48,65,387
Bud Norris,55.2,59,28,9,25,54,249

\end{verbatim}

\section{Complete Grammar}\label{grammar}

\begin{singlespacing}
\begin{verbatim}
%token identifier
%token string
%token number

%%
/***PROGRAM***/
program : statement_list
        ;

statement_list : statement
               | statement_list statement
               ;

statement : function_definition
          | sim_function_definition
          | body_statement
          ;

body_statement_list : body_statement
                    | body_statement_list body_statement
                    ;

/*Body Statements are all statements except function declarations*/
body_statement : if_statement
               | iteration_statement
               | jump_statement
               | declaration
               | stat_declaration
               | expression_statement
               | activate_statement
               | print_statement
               | assignment_statement
               ;

function_definition : "function" identifier "(" parameter_list0 ")"
        "returns" type ":" body_statement_list "end"
                    ;

parameter_list0 :
                | parameter_list
                ;

parameter_list : parameter
               | parameter_list "," parameter
               ;

parameter : type identifier
          ;

sim_function_definition : "simfunction" identifier "is:"
        body_statement_list "end" 
                        ;

activate_statement : "activate" identifier ";"
                   ;

print_statement : "print" expression ";"
                ;

if_statement : 
        "if" "(" expression ")" "then:" body_statement_list "end"
        | "if" "(" expression ")" "then:" body_statement_list
                else_statement "end"
        ;

else_statement : "else:" body_statement_list
               ;

/**ITERATION_STATEMENT**/
iteration_statement : 
        "do:" body_statement_list "end"
        | "do" expression "times:" body_statement_list "end"
        | "foreach" identifier "in" identifier ":" body_statement_list
                "end"
        ;

/**JUMP_STATEMENT**/
jump_statement : "stopdo" ";"
               | "return" expression ";"
               | "return" ";"
               ;
              
/**ASSIGNMENT_STATEMENT**/ 
assignment_statement : identifier assignment_operator expression ";"
                     ;

assignment_operator : "=" | "+=" | "-=" | "*=" | "/=" | "%=" ;

/**DECLARATION**/
declaration : type variable_declarators ";"
            ;

variable_declarators : variable_declarator
                     | variable_declarators "," variable_declarator
                     ;

variable_declarator : identifier
                    | identifier "=" expression
                    ;

stat_declaration : "stat" identifier "=" stat_expression ";"
                 ;

stat_expression : stat_mult_expr
                | stat_expression "+" stat_mult_expr
                | stat_expression "-" stat_mult_expr
                ;

stat_mult_expr : stat_atom_expr
               | stat_mult_expr "*" stat_atom_expr
               | stat_mult_expr "/" stat_atom_expr
               | stat_mult_expr "%" stat_atom_expr
               ;

stat_atom_expr : identifier
               | number
               | "(" stat_expression ")"
               ;

/*TYPE*/
type : "number"
     | "string"
     | "list"
     | "team"
     | "player"
     | "nothing"
     | list_type
     ;

list_type : "list" "of" type
          ;


/**EXPRESSION_STATEMENT**/
expression_statement : ";"
                     | expression ";"
                     ;

/*EXPRESSION*/
expression : logical_or_expression
           ;

/*LOGICAL*/
logical_or_expression : 
        logical_and_expression
        | logical_or_expression "or" logical_and_expression
        ;

logical_and_expression : 
        logical_not_expression
        | logical_and_expression "and" logical_not_expression
        ;

logical_not_expression : 
        comparison_expression
        | "not" logical_not_expression
        ;

/*COMPARISON*/
comparison_expression : 
        addition_expression
        | comparison_expression "is"   addition_expression
        | comparison_expression "isnot" addition_expression
        | comparison_expression ">"    addition_expression
        | comparison_expression "<"    addition_expression
        | comparison_expression ">="   addition_expression
        | comparison_expression "<="   addition_expression
        ;

/*ARITHMETIC*/
addition_expression : 
        multiplication_expression
        | addition_expression "+" multiplication_expression
        | addition_expression "-" multiplication_expression
        ;

multiplication_expression : 
        unary_expression
        | multiplication_expression "*" unary_expression
                        | multiplication_expression "/" unary_expression
                          | multiplication_expression "%" unary_expression
                          ;

/*UNARY*/
unary_expression : postfix_expression
                 | "++" unary_expression
                 | "--" unary_expression
                 | primary_expression "from" unary_expression
                 | "any" unary_expression
                 ;

/*POSTFIX*/
postfix_expression : primary_expression
                   | postfix_expression "'s" identifier // attribute/stats call
                   | postfix_expression "where" "(" expression ")"
                   | postfix_expression "++"
                   | postfix_expression "--"
                   ;

/*PRIMARY*/
primary_expression : atom_expression
                   | function_call
                   ;

/*FUNCTION_CALL*/
function_call : identifier "(" ")"
              | identifier "(" argument_list ")"
              ;

argument_list : expression
              | argument_list "," expression
              ;

/*ATOM_EXPRESSION*/
atom_expression : identifier
                | number
                | string
                | list_initializer
                | "nothing"
                | "(" expression ")" // completes the cycle
                ;

list_initializer : "[" variable_list "]"
                 | "[" "]"
                 ;

variable_list : expression
              | variable_list "," expression
              ;
%%
\end{verbatim}
\end{singlespacing}
