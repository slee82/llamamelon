#summary The full grammar for our language
#labels Phase-Design
_Refer to Appendix A13 of K&R. Also check http://java.sun.com/docs/books/jls/second_edition/html/syntax.doc.html _

<wiki:toc>

This is the yacc-compatible grammar for our language:

The grammar has the undefined terminal symbols: _identifier, string, number_.

{{{

%token identifier
%token string
%token number


%%
/***PROGRAM***/
program : statement_list
        ;

statement_list : statement
               | statement_list statement
               ;

statement : function_definition
          | sim_function_definition
          | body_statement
          ;

/*Body Statements are all statements except function declarations*/
body_statement : if_statement
               | iteration_statement
               | jump_statement
               | declaration
               | expression_statement
               | activate_statement
               | print_statement
               | assignment_statement
               ;

body_statement_list : body_statement
                    | body_statement_list body_statement
                    ;

function_definition : "function" identifier "(" parameter_list ")" "returns" type ":" body_statement_list "end"
                    ;

parameter_list : parameter
               | parameter_list "," parameter
               ;

parameter : type identifier
          ;

sim_function_definition : "simfunction" identifier "is:" body_statement_list "end"
                        ;

activate_statement : "activate" identifier ";"
                   ;

print_statement : "print" expression ";"
                ;

if_statement : "if" "(" expression ")" "then:" body_statement_list "end"
             | "if" "(" expression ")" "then:" body_statement_list else_statement "end"
             ;

else_statement : "else:" body_statement_list
               ;

iteration_statement : "do:" expression "times:" body_statement_list "end"
                    | "foreach" identifier "in" identifier ":" body_statement_list "end"
                    ;

jump_statement : "stopdo" ";"
               | "return" expression ";"
               | "return" ";"
               ;
               
assignment_statement : identifier assignment_operator expression ";"
                     ;

assignment_operator : "=" | "+=" | "-=" | "*=" | "/=" | "%=" ;

/*The declaration node in A13 of K&R is hard to follow. I feel like ours can be simpler, like the Java one.*/
declaration : type variable_declarators ";"
            ;

variable_declarators : variable_declarator
                     | variable_declarators "," variable_declarator
                     ;

variable_declarator : identifier
                    | identifier "=" expression
                    ;

type : "number"
     | "string"
     | "list"
     | "team"
     | "player"
     | "stat"
     | "nothing"
     ;

/* use multiple nonterminals to represent precedence, just like in the C grammar */

expression_statement : ";"
                     | expression ";"
                     ;

/* no C_style assignments in the middle of expressions (for now, unless everyone 
   wants it) */

expression : logical_or_expression
           ;

logical_or_expression : logical_and_expression
                      | logical_or_expression "or" logical_and_expression
                      ;

logical_and_expression : logical_not_expression
                       | logical_and_expression "and" logical_not_expression
                       ;

logical_not_expression : comparison_expression
                       | "not" logical_not_expression
                       ;

/* 
 * following Python where '==' is at the same preccedence as '>', '<', etc.
 * different from C where equality comes first. For example,
 *
 * "1 == 3 > 2" would return true in C, because the expression is evaluated as
 * "1 == (3 > 2)" instead of "(1 == 3) > 2", which is how Python interprets it.
 */

comparison_expression : addition_expression
                      | comparison_expression "is"   addition_expression
                      | comparison_expression "isnot" addition_expression
                      | comparison_expression ">"    addition_expression
                      | comparison_expression "<"    addition_expression
                      | comparison_expression ">="   addition_expression
                      | comparison_expression "<="   addition_expression
                      ;

addition_expression : multiplication_expression
                    | addition_expression "+" multiplication_expression
                    | addition_expression "-" multiplication_expression
                    ;

multiplication_expression : unary_expression
                          | multiplication_expression "*" unary_expression
                          | multiplication_expression "/" unary_expression
                          | multiplication_expression "%" unary_expression
                          ;

/* from C reference: "Expressions with unary operators group right to left" */
unary_expression : postfix_expression
                 | "++" unary_expression
                 | "--" unary_expression
                 | primary_expression "from" unary_expression
                 | "any" unary_expression
                 ;

/* from C reference: "The operators in postfix expressions group left to right" */
postfix_expression : primary_expression
                   | postfix_expression "'s" identifier // attribute/stats call
                   | postfix_expression "where" "(" expression ")"
                   | postfix_expression "++"
                   | postfix_expression "--"
                   ;

/*
 * since we're not going to pass around function pointers like C, calling
 * functions is as simple as getting an identifier, and can be pushed down to
 * "primary expressions"
 */

primary_expression : atom_expression
                   | function_call
                   ;

function_call : identifier "(" ")"
              | identifier "(" argument_list ")"
              ;

argument_list : expression
              | argument_list "," expression
              ;

atom_expression : identifier
                | number
                | string
                | list_initializer
                | "nothing"
                | "(" expression ")" // completes the cycle
                ;

list_initializer : "[" variable_list "]"
                 | "[" "]"
                 ;

variable_list : expression
              | variable_list "," expression
              ;
%%
}}}