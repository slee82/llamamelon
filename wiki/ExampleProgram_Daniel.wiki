#summary Daniel’s Example program and proposal.
#labels Phase-Design
<wiki:toc>

=The program=

{{{
/* Got the calculations from : http://sbs-baseball.com/theory.txt
  Check out http://en.wikipedia.org/wiki/Baseball_statistics*/

/*****************************************************/
/***STATS DEFINITION***/

/*Batter probabilities*/
stat bWalk = BB / PA;
stat bSingle = (Hits - (2B + 3B + HR))/ PA;
stat bDouble = 2B / PA;
stat bTriple = 3B / PA;
stat bHR = HR / PA;

/*Pitcher probabilities*/
stat pWalk = BB / BF;
stat pSingle = (Hits / BF) - pHR - pTriple - pDouble;
stat pDouble = Hits x .174 / BF;
stat pTriple = Hits x .024 / BF;
stat pHR = HR / BF;

/***END STATS DEFINITION***/
/*****************************************************/

/*Global variables that hold combined probabilities given a pitcher and a batter*/
number probWalk = 0;
number probSingle = 0;
number probDouble = 0;
number probTriple = 0;
number probHR = 0;


/*BASIC SIMULATION FUNCTION: simplifies the problem by pretending that
this is a game between the batter and the pitcher. To further simplify
the problem: let’s assume that a home run is worth 1 point to the batting 
team, singles and walks are worth 1/4 of a point, doubles are 1/2 a point
and triples are 3/4 of a point.*/

simfunction basicSimulation is:

  number team1Score = 0;
  number team2Score = 0;

  /*Note: team1 and team2 are global variables that represent the teams that the
  sim function is currently working with. The sim function sets them automatically.*/

  /*team1 is batting and team2 is pitching! (5 times)*/

  for i from 1 to 5 step 1 do:
    /*Select random players from the best 5 of each team*/
    player batter = any from team1 where (type is "batter" and AVG is top 5);
    player pitcher = any from team2 where (type is "pitcher" and ERA is lowest 5);
    /*I am introducing new conditional shortcuts ’top’ and ’lowest’ because doing ’AVG > 3.0’ might
    not work for a team with bad players (would return no players). I think these keywords come
    in handy for selecting best players, which is something you do a lot when simulating baseball.
    Our language should be good for simulating sports games by providing shortcuts like these*/

    /*Set the global probabilities of this inning*/
    combineProb(batter, pitcher);

    /*Add a little sugar*/
    randomizeProbabilities();

    team1Score += probWalk*(1/4) + probSingle*(1/4) + probDouble*(2/4) + probTriple*(3/4) + probHR;    
  end

  /*NOW, team2 is batting and team1 is pitching! (5 times)*/

  for i from 1 to 5 step 1 do:
    player batter = any from team2 where (type is "batter" and AVG is top 5);
    player pitcher = any from team1 where (type is "pitcher" and ERA is lowest 5);
    
    combineProb(batter, pitcher);

    randomizeProbabilities();

    team2Score += probWalk*(1/4) + probSingle*(1/4) + probDouble*(2/4) + probTriple*(3/4) + probHR;    
  end

  if (team1Score > team2Score) then:
    print "Team " + team1’s name + " wins against team " + team2’s name + "!!";
    return team1;
  else
    print "Team " + team2’s name + " wins against team " + team1’s name + "!!";
    return team2;
  end

end
/*END BASIC SIMULATION FUNCTION*/

/*Declaring a general-purpose function that calculates
combined probabilities given a pitcher and a batter.
It takes the max of both: average is not a good estimate.*/
function combineProb (player batter, player pitcher) is:

  /*Having Min and Max functions can be useful in situations like these*/
  probWalk = max(pitcher’s pWalk, batter’s bWalk);
  probSingle = max(pitcher’s pSingle, batter’s bSingle);
  probDouble = max(pitcher’s pDouble, batter’s bDouble);
  probTriple = max(pitcher’s pTriple, batter’s bTriple);
  probHR = max(pitcher’s pHR, batter’s bHR);

end

/*General Purpose function that takes the values generated by combineProb and
randomizes them (gives them 10% of jimmy-jammy-ness) for more realistic results*/
function randomizeProbabilities() is:

  probWalk = rand(probWalk - probWalk*.1, probWalk + probWalk*.1);
  probSingle = rand(probSingle - probSingle*.1, probSingle + probSingle*.1);
  probDouble = rand(probDouble - probDouble*.1, probDouble + probDouble*.1);
  probTriple = rand(probTriple - probTriple*.1, probTriple + probTriple*.1);
  probHR = rand(probHR - probHR*.1, probHR + probHR*.1);

end

/*This makes simFunc the active simulation function, for use in the
  following nested simulations (so we don’t have to pass it multiple times).*/
activate basicSimulation;

team winner = sim((Astros, Dodgers, 3), (Orioles, Twins, 3), 3);
print "Team " + winner’s name + " has won the championship!!\n";

print "Team " + winner’s name + " has the players:";
foreach winner as winnerPlayer do:
  print winnerPlayer’s name;
end
}}}


=Program output=

The output will be something like:

{{{
Team Dodgers wins against team Astros!!
Team Orioles wins against team Twins!!
Team Dodgers wins agains team Orioles!!
Team Dodgers has won the championship!!

Team Dodgers has the players:
Ronald Belisario	
Chad Billingsley	
Jonathan Broxton
Scott Elbert
Jon Garland
Charlie Haeger
Clayton Kershaw
Hong-Chih Kuo
Hiroki Kuroda
Brent Leach
James McDonald
Guillermo Mota
etc...
}}}


=Further explanations=

  * At first, I define new stats for the probability of walks, singles, doubles, triples, home-runs for pitchers and batters.
  * Then, I set global variables for the overall probability of a walk, single, etc... _given_ a specific batter and pitcher.
  * I define my simulation function:
    * takes no arguments, must return a team!
    * team1 bats and team2 pitches 5 times, and vice versa.
    * the team’s score is determined by the overall probability of walks, singles, etc... depending on the randomly selected top 5 players.
    * the randomness factor is introduced by letting the global probabilities vary by 10%.
  * I then set my simulation function as 'active' because I don't want to have to type something like
  {{{sim((Astros, Dodgers, 3, basicSimulation), (Orioles, Twins, 3, basicSimulation), 3, basicSimulation);}}}
  * The sim function returns the winning team after 3 games.

=Syntax properties=

  * Ending every clause with 'end'. (I don't mind using any other token, as long as we use one).
  * Starting function bodies with 'is:', if statement bodies with 'then:' and for loop bodies with 'do:'.
  * Getting rid of 'define': A token that serves no purpose.
  * Using ';' to terminate commands: I don't mind using '@', '#' or whatever, but I think '.' would cause huge parsing conflicts.
  * Defining simulation functions: The compiler will complain unless the function takes no arguments and returns a team. No need to put () after the name here.
  * Comma-saparated parameter declaration and passing: {{{combineProb(batter, pitcher);}}}
  * Java operators such as '+=' or '++' for numbers and '+' for string concatenation are very easy to implement: just pass the code directly to the Java compiler... so why not implement them?

  * *Keywords/Shortcuts (in order of appearance)*
    * *'any'*: following Cipta's example, this selects a random item from a set.
    * *'from'*: This keyword might be superfluous, but it makes the english sound better: it indicates the set from which to select an item.
    * *'where'*: acts as a filter for the 'from' keyword: returns a smaller set that satisfies the conditionals.
    * *'is'* conditional: Although I like using < and > for comparison, I think 'is' sounds better than '=='. The opposite could be 'isnot' or 'isnt'.
    * *'and'* instead of && and 'or' instead of ||.
    * *'top `<number>`'* and *'lowest `<number>`'* are _very_ handy shortcuts for use with the 'where' keyword that returns a sub-list with the best or worst items depending on a stat or property. For example:
  {{{where (type is "batter" and AVG is top 5);}}}
    returns a list of 5 players that are top 5 in AVG.
    * *'all'*: although I haven't demonstrated this keyword here, it would work similarly to 'any' but would return a list instead of a random item. Useful in scenarios such as:
{{{
list bestBatters = all from Dodgers where (type is "batter" and AVG > 0.3);

foreach bestBatters as someAwesomePlayer do:
  print "The player " + someAwesomePlayer + "has a batting average over 3.0!";
end
}}}
  
  * *Clauses*
    * *for loops*: not used to iterate through a list, but rather to loop a certain number of times using an incremented variable:
{{{
for i from 1 to 5 step 1 do:
  someNumber = i;
end
}}}
    * *foreach loops*: This is used to iterate through a list, check this out: http://php.net/manual/en/control-structures.foreach.php
{{{
print "The Dodgers roster is:"
foreach Dodgers as aDodgerPlayer do:
 print aDodgerPlayer;
end
}}}
    * *if statements*: {{{if (condition) then: <action> elseif (condition) then <action> else <action> end}}}
    I think it is wise to put () around conditionals such as 
{{{
if (myNumber > yourNumber and yourNumber isnt 0) then:
    return myNumber
}}}
{{{
player batter = any from team1 where (type is "batter" and (AVG > 0.3 or PA > 200));
}}}
    because condition clauses can have a lots of 'and's and 'or's and nested conditions.

  * *Primitives and data types*
    * *numbers*: {{{number someNumber = 10;}}}
    * *strings*: {{{string sString = "Hello, World!";}}}
    * *teams*: {{{team Dodgers = load(Dodgers.cvs);}}}
    * *players*: {{{player Juan = "Juan Castro" from Dodgers;}}}
    * *lists/sets*: Although I have't done any list manipulation in my program, I use lists a lot with the 'any' and 'from' keywords. I might want to create my own lists for different purposes.
{{{
list twoTeams = [Dodgers, Astros];

list allTeams = twoTeams + [Pirates, Orioles];
/*The list allTeams now contains [Dodgers, Astros, Pirates, Orioles].*/

allTeams = allTeams - [Orioles];
/*The list allTeams now contains [Dodgers, Astros, Pirates].*/

foreach allTeams as opposingTeam do:
  team winner = sim(opposingTeam, Twins, 3);
  print winner’s name + " wins!";
end 
}}}